synchronized:
    （jvm的）
    关键点：同步的内容是什么；调用的对象是什么。两个方向去思考。
    特点：不可中断锁，适合竞争不激烈，可读性好。
    有四种使用方式（四种修饰方法）
    1）同步代码块
    2）同步方法
    3）修饰静态方法 : 多个线程同时操作 都是线程安全的
    4）修饰静态类
    jvm关于synchronized的两条规定
    1，线程解锁前，必须把共享变量的最新值刷新到主内存
    2，线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。
       （注意：加锁与解锁是同一把锁）
    synchronized的可见性和原子性
Lock:
    （cpu的）
    特点：可中断锁，多样化同步，竞争激烈时能维持常态。
Atomic:
    特点：竞争激烈时能维持常态，比Lock性能好；只能同步一个值。

------------------------------------------------
volatile: （cpu级别的）
    可见性：
    1；对变量写操作时，写操作之后加一条store屏障指令，将本地内存中的变量值刷新到主内存
    2，对变量读操作时，在读之前加一条load屏障指令，从主内存中读取共享变量。
    （一个线程操作变量，读要从主内存中读，写要写到主内存中。）
    count++ 场景使用volatile修饰，达不到线程安全的，它不是线程安全的关键字。
    从主内存中读取count，对其进行加1操作，将count写到主内存中。
    volative的使用场景是：
    状态标记量；D:\idea_workspace\demo\src\main\java\com\example\demo\volatileDemo.java
    检查两次，防止指令重排。D:\idea_workspace\demo\src\main\java\com\example\demo\singleton\SingletonExample3.java

------------------------------------------------
线程安全性：
原子性：Atomic包，CAS算法，synchronized(四种), Lock
    同一时刻 只有一个线程去访问，线程之间是互斥的。
可见性：synchronized,volatile
    一个线程对主内存的修改可以及时的被其他线程观察到。
有序性：happens-before原则
    指令有重排序的特征。volatile可限制指令重排。
------------------------------------------------