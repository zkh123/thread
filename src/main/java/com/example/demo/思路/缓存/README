一般的流程：
浏览器--网络转发linux--服务a/服务b/服务c---数据库/文件系统存储

数据库每秒接触的处理量 也是有限的。
引入缓存--->减少计算次数

缓存特征：
1, 命中率 (越高越好)
   命中：通过缓存 获取想要的数据。
2, 最大元素 (空间)
   超过最大 会触发缓存清空策略的操作，这就不好了。
   清空策略：FIFO, LFU,LRU,过期时间,随机等  (都是一些算法)

影响缓存命中率的几个因素：
1, 业务场景和业务需求
2, 缓存的设计(粒度和策略)
   缓存单个对象，缓存一个集合，等等
3, 缓存的容量和基础设施
   本地单机缓存，分布式缓存...
   一致性哈希算法 节点冗余 算法

缓存分类和应用场景：
1, 本地缓存 ： 成员变量，局部变量，静态变量
    Guava Cache (这是一个东西)
2, 分布式缓存: 独立组件
    Memcache, Redis

介绍：
Guava Cache (类似实现了ConcurrentHashMap)
多个Segment的分布式锁

Memcache 本身不提供分布式解决方案
         它的分布式 主要是在客户端实现的，客户端进行路由。
         Memcache 部署多台node节点
         内存结构：
         slab_class ---slab     1兆
                    ---slab --- page      88字节
                            --- page --- chunk
                                     --- chunk
          1，chunk总是有浪费
          2，lru算法 针对slab的
          3，value的大小 不能超过1兆的
          4，key是250个字节的,超过是没法存储的

redis:非关系性 远程服务数据库
      数据持久化大硬盘
      可以使用复制特性来扩张读性能
      客户端分片 提高写性能

      性能极高 11万次每秒 读
              8万一千次每秒 写
      原子性
      数据结构五种
      消息通知

高并发下缓存的问题
1, 缓存一致性
    缓存的数据 和 数据库中的数据 缓存副本的数据一致性
    缓存过期 和 缓存策略
2, 缓存并发问题
    使用锁的机制
3, 缓存穿透性问题
    如果一个key没有命中 会去数据库查询，如果该key的数据库中没有，就会导致很多没有必要的操作
    解决：1, 对结果为空的数据 也进行缓存
         2,  缓存数据进行时效性处理
4, 缓存的雪崩现象
    缓存抖动：缓存节点故障导致  一致性哈希算法来解决
    由于系统的原因导致大量的请求打到数据库 从而导致数据库奔溃以及系统的崩溃。
    缓存集中失效

